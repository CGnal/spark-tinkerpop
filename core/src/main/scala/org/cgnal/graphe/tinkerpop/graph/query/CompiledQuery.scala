package org.cgnal.graphe.tinkerpop.graph.query

import javax.script.{ Bindings, CompiledScript }

/**
 * Container class for `CompiledScript` values and their raw counterpart; mainly useful to keep the original
 * script bound with the `CompiledScript` generated by the chosen `ScriptEngine` implementation.
 * @param originalScript the raw string representing the script
 * @param compiledScript the result of compiling `originalScript` with a particular `ScriptEngine` implementation
 */
case class CompiledQuery(originalScript: String, compiledScript: CompiledScript) {

  /**
   * The type of query the original script represents. By default this is a `VertexQueryType` when the `originalScript`
   * uses `v` as its starting reference, and `EdgeQueryType` when using `e` instead.
   */
  final lazy val queryType = QueryTypes.fromScript(originalScript)

  private def validateBindings[A](bindings: Bindings)(f: => A) =
    if (!bindings.containsKey(queryType.binding)) throw new IllegalArgumentException(s"No binding available for [${queryType.binding}]")
    else f

  /**
   * Evaluates (/runs) the compiled scripts against the given bindings.
   * @param bindings the bindings needed to run the script; note that there must be a binding corresponding to the
   *                 relevant `queryType`
   * @return the result of evaluating `compiledScript` as a `ScriptResult` with the given bindings
   */
  final def eval(bindings: Bindings) = validateBindings(bindings) { ScriptResult(compiledScript.eval(bindings), bindings, queryType) }

}
